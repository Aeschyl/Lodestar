
//AutoGenerated Using QuickType
namespace Json
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using System.Linq;
    using System.Text;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class Results
    {
        [JsonProperty("type")]
        public string Type { get; set; }

        [JsonProperty("features")]
        public List<Feature> Features { get; set; }
    }

    public partial class Feature
    {
        [JsonProperty("type")]
        public FeatureType Type { get; set; }

        [JsonProperty("properties")]
        public Properties Properties { get; set; }

        [JsonProperty("geometry")]
        public Geometry Geometry { get; set; }
    }

    public partial class Geometry
    {
        [JsonProperty("type")]
        public GeometryType Type { get; set; }

        [JsonProperty("coordinates")]
        public List<double> Coordinates { get; set; }
    }

    public partial class Properties
    {
        [JsonProperty("name")]
        public string Name { get; set; }

        [JsonProperty("housenumber", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(ParseStringConverter))]
        public long? Housenumber { get; set; }

        [JsonProperty("street")]
        public string Street { get; set; }

        [JsonProperty("quarter", NullValueHandling = NullValueHandling.Ignore)]
        public string Quarter { get; set; }

        [JsonProperty("neighbourhood", NullValueHandling = NullValueHandling.Ignore)]
        public string Neighbourhood { get; set; }

        [JsonProperty("suburb")]
        public string Suburb { get; set; }

        [JsonProperty("city")]
        public City City { get; set; }

        [JsonProperty("state")]
        public State State { get; set; }

        [JsonProperty("postcode")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long Postcode { get; set; }

        [JsonProperty("country")]
        public Country Country { get; set; }

        [JsonProperty("country_code")]
        public CountryCode CountryCode { get; set; }

        [JsonProperty("lon")]
        public double Lon { get; set; }

        [JsonProperty("lat")]
        public double Lat { get; set; }

        [JsonProperty("formatted")]
        public string Formatted { get; set; }

        [JsonProperty("address_line1")]
        public string AddressLine1 { get; set; }

        [JsonProperty("address_line2")]
        public string AddressLine2 { get; set; }

        [JsonProperty("categories")]
        public List<string> Categories { get; set; }

        [JsonProperty("details")]
        public List<Detail> Details { get; set; }

        [JsonProperty("datasource")]
        public Datasource Datasource { get; set; }

        [JsonProperty("place_id")]
        public string PlaceId { get; set; }

        [JsonProperty("old_name", NullValueHandling = NullValueHandling.Ignore)]
        public string OldName { get; set; }

        [JsonProperty("district", NullValueHandling = NullValueHandling.Ignore)]
        public string District { get; set; }

        public override string ToString()
        {
            return GetType().GetProperties()
                .Select(info => (info.Name, Value: info.GetValue(this, null) ?? "(null)"))
                .Aggregate(
                    new StringBuilder(),
                    (sb, pair) => sb.AppendLine($"{pair.Name}: {pair.Value}"),
                    sb => sb.ToString());
        }
    }

    public partial class Datasource
    {
        [JsonProperty("sourcename")]
        public Sourcename Sourcename { get; set; }

        [JsonProperty("attribution")]
        public Attribution Attribution { get; set; }

        [JsonProperty("license")]
        public License License { get; set; }

        [JsonProperty("url")]
        public Uri Url { get; set; }
    }

    public enum GeometryType { Point };

    public enum City { Munich };

    public enum Country { Germany };

    public enum CountryCode { De };

    public enum Attribution { OpenStreetMapContributors };

    public enum License { OpenDatabaseLicence };

    public enum Sourcename { Openstreetmap };

    public enum Detail { Details, DetailsBuilding, DetailsCatering, DetailsContact, DetailsFacilities, DetailsHistoric, DetailsPayment, DetailsWikiAndMedia };

    public enum State { Bavaria };

    public enum FeatureType { Feature };

    public partial class Results
    {
        public static Results FromJson(string json) => JsonConvert.DeserializeObject<Results>(json, Json.Converter.Settings);
        public override string ToString()
        {
            return GetType().GetProperties()
                .Select(info => (info.Name, Value: info.GetValue(this, null) ?? "(null)"))
                .Aggregate(
                    new StringBuilder(),
                    (sb, pair) => sb.AppendLine($"{pair.Name}: {pair.Value}"),
                    sb => sb.ToString());
        }
    }

    public static class Serialize
    {
        public static string ToJson(this Results self) => JsonConvert.SerializeObject(self, Json.Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                GeometryTypeConverter.Singleton,
                CityConverter.Singleton,
                CountryConverter.Singleton,
                CountryCodeConverter.Singleton,
                AttributionConverter.Singleton,
                LicenseConverter.Singleton,
                SourcenameConverter.Singleton,
                DetailConverter.Singleton,
                StateConverter.Singleton,
                FeatureTypeConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class GeometryTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(GeometryType) || t == typeof(GeometryType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null)
                return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "Point")
            {
                return GeometryType.Point;
            }
            throw new Exception("Cannot unmarshal type GeometryType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (GeometryType)untypedValue;
            if (value == GeometryType.Point)
            {
                serializer.Serialize(writer, "Point");
                return;
            }
            throw new Exception("Cannot marshal type GeometryType");
        }

        public static readonly GeometryTypeConverter Singleton = new GeometryTypeConverter();
    }

    internal class CityConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(City) || t == typeof(City?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null)
                return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "Munich")
            {
                return City.Munich;
            }
            throw new Exception("Cannot unmarshal type City");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (City)untypedValue;
            if (value == City.Munich)
            {
                serializer.Serialize(writer, "Munich");
                return;
            }
            throw new Exception("Cannot marshal type City");
        }

        public static readonly CityConverter Singleton = new CityConverter();
    }

    internal class CountryConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Country) || t == typeof(Country?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null)
                return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "Germany")
            {
                return Country.Germany;
            }
            throw new Exception("Cannot unmarshal type Country");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Country)untypedValue;
            if (value == Country.Germany)
            {
                serializer.Serialize(writer, "Germany");
                return;
            }
            throw new Exception("Cannot marshal type Country");
        }

        public static readonly CountryConverter Singleton = new CountryConverter();
    }

    internal class CountryCodeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(CountryCode) || t == typeof(CountryCode?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null)
                return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "de")
            {
                return CountryCode.De;
            }
            throw new Exception("Cannot unmarshal type CountryCode");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (CountryCode)untypedValue;
            if (value == CountryCode.De)
            {
                serializer.Serialize(writer, "de");
                return;
            }
            throw new Exception("Cannot marshal type CountryCode");
        }

        public static readonly CountryCodeConverter Singleton = new CountryCodeConverter();
    }

    internal class AttributionConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Attribution) || t == typeof(Attribution?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null)
                return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "© OpenStreetMap contributors")
            {
                return Attribution.OpenStreetMapContributors;
            }
            throw new Exception("Cannot unmarshal type Attribution");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Attribution)untypedValue;
            if (value == Attribution.OpenStreetMapContributors)
            {
                serializer.Serialize(writer, "© OpenStreetMap contributors");
                return;
            }
            throw new Exception("Cannot marshal type Attribution");
        }

        public static readonly AttributionConverter Singleton = new AttributionConverter();
    }

    internal class LicenseConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(License) || t == typeof(License?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null)
                return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "Open Database Licence")
            {
                return License.OpenDatabaseLicence;
            }
            throw new Exception("Cannot unmarshal type License");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (License)untypedValue;
            if (value == License.OpenDatabaseLicence)
            {
                serializer.Serialize(writer, "Open Database Licence");
                return;
            }
            throw new Exception("Cannot marshal type License");
        }

        public static readonly LicenseConverter Singleton = new LicenseConverter();
    }

    internal class SourcenameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Sourcename) || t == typeof(Sourcename?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null)
                return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "openstreetmap")
            {
                return Sourcename.Openstreetmap;
            }
            throw new Exception("Cannot unmarshal type Sourcename");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Sourcename)untypedValue;
            if (value == Sourcename.Openstreetmap)
            {
                serializer.Serialize(writer, "openstreetmap");
                return;
            }
            throw new Exception("Cannot marshal type Sourcename");
        }

        public static readonly SourcenameConverter Singleton = new SourcenameConverter();
    }

    internal class DetailConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Detail) || t == typeof(Detail?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null)
                return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "details":
                    return Detail.Details;
                case "details.building":
                    return Detail.DetailsBuilding;
                case "details.catering":
                    return Detail.DetailsCatering;
                case "details.contact":
                    return Detail.DetailsContact;
                case "details.facilities":
                    return Detail.DetailsFacilities;
                case "details.historic":
                    return Detail.DetailsHistoric;
                case "details.payment":
                    return Detail.DetailsPayment;
                case "details.wiki_and_media":
                    return Detail.DetailsWikiAndMedia;
            }
            throw new Exception("Cannot unmarshal type Detail");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Detail)untypedValue;
            switch (value)
            {
                case Detail.Details:
                    serializer.Serialize(writer, "details");
                    return;
                case Detail.DetailsBuilding:
                    serializer.Serialize(writer, "details.building");
                    return;
                case Detail.DetailsCatering:
                    serializer.Serialize(writer, "details.catering");
                    return;
                case Detail.DetailsContact:
                    serializer.Serialize(writer, "details.contact");
                    return;
                case Detail.DetailsFacilities:
                    serializer.Serialize(writer, "details.facilities");
                    return;
                case Detail.DetailsHistoric:
                    serializer.Serialize(writer, "details.historic");
                    return;
                case Detail.DetailsPayment:
                    serializer.Serialize(writer, "details.payment");
                    return;
                case Detail.DetailsWikiAndMedia:
                    serializer.Serialize(writer, "details.wiki_and_media");
                    return;
            }
            throw new Exception("Cannot marshal type Detail");
        }

        public static readonly DetailConverter Singleton = new DetailConverter();
    }

    internal class ParseStringConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(long) || t == typeof(long?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null)
                return null;
            var value = serializer.Deserialize<string>(reader);
            long l;
            if (Int64.TryParse(value, out l))
            {
                return l;
            }
            throw new Exception("Cannot unmarshal type long");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (long)untypedValue;
            serializer.Serialize(writer, value.ToString());
            return;
        }

        public static readonly ParseStringConverter Singleton = new ParseStringConverter();
    }

    internal class StateConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(State) || t == typeof(State?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null)
                return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "Bavaria")
            {
                return State.Bavaria;
            }
            throw new Exception("Cannot unmarshal type State");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (State)untypedValue;
            if (value == State.Bavaria)
            {
                serializer.Serialize(writer, "Bavaria");
                return;
            }
            throw new Exception("Cannot marshal type State");
        }

        public static readonly StateConverter Singleton = new StateConverter();
    }

    internal class FeatureTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(FeatureType) || t == typeof(FeatureType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null)
                return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "Feature")
            {
                return FeatureType.Feature;
            }
            throw new Exception("Cannot unmarshal type FeatureType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (FeatureType)untypedValue;
            if (value == FeatureType.Feature)
            {
                serializer.Serialize(writer, "Feature");
                return;
            }
            throw new Exception("Cannot marshal type FeatureType");
        }

        public static readonly FeatureTypeConverter Singleton = new FeatureTypeConverter();
    }
}
